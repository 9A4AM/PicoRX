.program hello
	set pins, 0
	set pins, 1      ; Drive pin low
	set pins, 3      ; Drive pin high
	set pins, 2      ; Drive pin low

% c-sdk {
#include "hardware/clocks.h"
static inline float nco_program_init(PIO pio, uint sm, uint offset, float tuned_frequency) {
    pio_sm_config c = hello_program_get_default_config(offset);

    // Map the state machine's OUT pin group to one pin, namely the `pin`
    // parameter to this function.
    sm_config_set_set_pins(&c, 0, 2);

    // Set this pin's GPIO function (connect PIO to the pad)
    pio_gpio_init(pio, 0);
    pio_gpio_init(pio, 1);
    gpio_set_drive_strength(0, GPIO_DRIVE_STRENGTH_2MA);
    gpio_set_drive_strength(1, GPIO_DRIVE_STRENGTH_2MA);
    gpio_set_slew_rate(0, GPIO_SLEW_RATE_SLOW);
    gpio_set_slew_rate(1, GPIO_SLEW_RATE_SLOW);

    // Set the pin direction to output at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, 0, 2, true);


    //We can get closer to the derired frequency if we allow small adjustments
    //to the system clock. system clocks in the range 125 - 133 MHz are fast
    //enough to run the software. There are nearly 50 different frequencies in this
    //range, by chosing the frequency that gives the best match, we can get within about 4Khz.

    struct PLLSettings{
      uint32_t frequency;
      uint8_t refdiv;
      uint16_t fbdiv;
      uint8_t postdiv1;
      uint8_t postdiv2;
    };

    //A list of all the achievable frequencies in range
    PLLSettings possible_frequencies[] = {
    {125000000, 1, 125, 6, 2},
    {125142857, 1, 73, 7, 1},
    {125333333, 1, 94, 3, 3},
    {126000000, 1, 126, 6, 2},
    {126666666, 1, 95, 3, 3},
    {126857142, 1, 74, 7, 1},
    {127000000, 1, 127, 6, 2},
    {127200000, 1, 106, 5, 2},
    {127500000, 1, 85, 4, 2},
    {128000000, 1, 128, 6, 2},
    {128400000, 1, 107, 5, 2},
    {128571428, 1, 75, 7, 1},
    {129000000, 1, 129, 6, 2},
    {129333333, 1, 97, 3, 3},
    {129600000, 1, 108, 5, 2},
    {130000000, 1, 130, 6, 2},
    {130285714, 1, 76, 7, 1},
    {130500000, 1, 87, 4, 2},
    {130666666, 1, 98, 3, 3},
    {130800000, 1, 109, 5, 2},
    {131000000, 1, 131, 6, 2},
    {132000000, 1, 132, 6, 2},
    {133000000, 1, 133, 6, 2},
    };

    float adjusted_frequency_up = tuned_frequency + 6000;
    float adjusted_frequency_down = tuned_frequency - 6000;
    PLLSettings best_settings;
    float best_frequency = 1;
    float best_divider;
    float best_error=1000000;

    best_frequency = 1;
    
    for(uint8_t idx = 0; idx < sizeof(possible_frequencies)/sizeof(PLLSettings); idx++)
    {

      float system_clock_frequency = possible_frequencies[idx].frequency;

      float ideal_divider = system_clock_frequency/(4.0f*adjusted_frequency_up);
      float nearest_divider = round(256.0f*ideal_divider)/256.0f;
      float actual_frequency = system_clock_frequency/nearest_divider;
      float error = abs(actual_frequency - 4.0f*adjusted_frequency_up);
      if(error < best_error)
      {
        best_frequency = actual_frequency;
        best_settings = possible_frequencies[idx];
        best_divider = nearest_divider;
        best_error = error;
      }

      ideal_divider = system_clock_frequency/(4.0f*adjusted_frequency_down);
      nearest_divider = round(256.0f*ideal_divider)/256.0f;
      actual_frequency = system_clock_frequency/nearest_divider;
      error = abs(actual_frequency - 4.0f*adjusted_frequency_down);
      if(error < best_error)
      {
        best_frequency = actual_frequency;
        best_settings = possible_frequencies[idx];
        best_divider = nearest_divider;
        best_error = error;
      }
    }

    //adjust system clock
    uint32_t vco_freq = (12000000 / best_settings.refdiv) * best_settings.fbdiv;
    set_sys_clock_pll(vco_freq, best_settings.postdiv1, best_settings.postdiv2);

    //set pio divider
    sm_config_set_clkdiv(&c, best_divider);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);

    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);

    //return actual frequency
    return best_frequency/4.0f;
}
%}
